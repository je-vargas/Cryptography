
def mod_addition(x, y, mod):
    return ((x + y) % mod)

def mod_subtraction(x, y, mod):
    return ((x - y) % mod)

def mod_multiplication(x, y, mod):
    return ((x * y) % mod)

def mod_inverse(x, mod):
    for a in range(1, mod):
        if (mod_multiplication(a, x, mod) == 1):
            # print(f"inverse: {a} for prime: {x}")
            print(f"d={x}, e={a}")
            return a
    return -1

def mod_division(dividend, divisor, mod):
    inverse = mod_inverse(divisor, mod)
    if inverse == 1:
        print("mod_inverse returned: {0}".format(inverse))
    return mod_multiplication(dividend, inverse, mod)

def mod_square_root(x, mod):
    for a in range(1, mod):
        square = pow(a, 2)
        if ((square % mod) == x):
            return a
    return 0

def mod_power_to(x, power, mod):
    xToPower = pow(x, power)
    return (xToPower % mod)

def int_to_string(n, alphabet_set):
    '''
        FUNCTION: int_to_string
        DEFINITION: Maps a big integer into a possible solution for the set password length
        PARAMETERS: n: int, alphabet_set: list(string)
        RETURNS: s: int
    '''
    s = ""
    base = alphabet_set
    # base = len(alphabet_set)

    while n >= 0:
        remainder = n % base
        n = n // base #* int division
        # s = s + str(alphabet_set[remainder]) 
        n = n - 1
    return s

import sympy

# a = sympy.primerange(108)
# for i in a: 
#     print(i)


a = [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107]
ch = list()

for i in a: 

    d = mod_inverse(i, 108)
    # print(d)
    ch.append(d)


# a = 7*31
# # print(a % 108)
# print(pow(8, 43))


